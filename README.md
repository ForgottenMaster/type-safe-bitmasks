# Overview
This header-only library is designed to allow easy creation of type-safe bitmask structures which are themselves designed to not allow any undefined behaviour and whose operations are designed to keep the internal state valid.

The type safety offered by the library is intended to avoid the kinds of bugs that can accidentally occur with untyped bitmasks such as raw integers.

# Usage
This section displays a sample usage of the library macro in order to give a point of reference for the remaining sections.

```cpp
#include "bitmask.h"

DECLARE_BITMASK_ENUM(Foo, Value_1, Value_2, Value_3);

constexpr auto bitmask = Foo::Value_1 | Foo::Value_2;
constexpr auto bit = Foo::Value_1;
static_assert((bitmask & bit) == bit, "Failed assertion that bit is set in the bitmask"); // shouldn't fail
```

# The Macros
While the header of the library is over 670 lines of code, it's mainly due to the many internal macros required due to the preprocessor not allowing recursion or overloading. There are only 5 macros used from a user's point of view, and one of those is an alias.

The macros are all of the form "DECLARE_BITMASK_ENUM_X" where X defines the backing type size and allowed maximum number of bits/variants (checked at compile time).

The backing type is always an unsigned integer and is one of 8, 16, 32, or 64 bits. It was decided to not allow selection of the backing type and only of the bit count because it's unnecessary for it to be represented as anything other than an unsigned integer.

Additionally, the user is able to specify the name of the generated type, along with the bit names, but is not able to specify the integer values for the bits. This is because when dealing with bitmasks and bits, we only really need care about the names of the bits, and in most cases, individual bits represented in the enumeration are assigned continuous, ascending powers of two. We shouldn't give the user the opportunity to set their own values because it would allow for accidental issues such as assigning a non power of two, or repeating values.

The 4 macros therefore are as demonstrated below

```cpp
DECLARE_BITMASK_ENUM_8(Bitmask8, V1, V2, V3);
DECLARE_BITMASK_ENUM_16(Bitmask16, V1, V2, V3);
DECLARE_BITMASK_ENUM_32(Bitmask32, V1, V2);
DECLARE_BITMASK_ENUM_64(Bitmask64, V1, V2, V3, V4);
```
  
The additional 5th macro is used when we don't want to define a bit count and is an alias for the 64 bit variant to allow maximum number of values to be specified.

Also as mentioned, the number of variants passed to the macro is checked against the bit count used so the user cannot define more than the underlying type can represent.

# Bitmasks and Bits
In order to leverage the type system and to provide correct functionality, it's necessary to separate the idea of an individual bit from a bitmask. The library therefore keeps these type separated, with differing internal representations, and operations defined to leave entities in a valid state. This section will explain these two distinct classes and what can be done with them.

## Bit
An instance of the Bit class is a thin wrapper around a value of the enum class that was generated by the macros. This wrapping is necessary to allow us to extend the enum class with operations we need.

Conceptually an instance of the Bit class represents a single bit in a bitmask. Aside from bitwise operations, the Bit instances can be streamed to a std::ostream instance, and implicitly converted to the underlying enum class value. This latter functionality is required to be able to use a Bit instance in a switch statement, with the added benefit of the compiler warning you about the unused cases. It is totally safe to convert a Bit instance to an enum class value as it's a direct 1-to-1 mapping. Unlike with bitmasks.

## Bitmask
An instance of the Bitmask class represents the potential for multiple bits being set in the underlying representation. While with a Bit instance, we can guarantee that it's representative of only a single value in the strongly typed enum class, allowing for switch statements to work, we cannot give such guarantees on a Bitmask. As such, a bitmask is represented under the hood as the raw underlying integer type.

Aside from bitwise operations we can perform on Bitmasks, they are also able to be streamed to a std::ostream and additionally we are able to safely promote a Bit instance to a Bitmask as this is a totally safe conversion.

# Accessing Bits
Calling the macro to generate a bitmask type will generate not only the enum class with correct shifted values for the variants, but also, for each variant, will construct a Bit instance and make it available as a static member on the named class.

# Constexpr Compatible
All of the Bit instances, the bitwise operators, and conversion operators are constexpr compatible, and so can be used in constexpr contexts such as using static_asserts to verify the behaviour of the API.

# Limitations
There are limitations and/or as of yet unimplemented features:
* The user cannot convert to and from the underlying representation of the bitmask/bit, therefore direct serialization like this is not possible currently. Accepting a raw integer to construct a Bitmask would break the strong compile time guarantees we have from types, so I don't want to allow this and probably need to think of another way to do this (possibly using arrays of Bit instances).
* Bitmasks can only be constructed with up to 64 variants/bits.
* The bitwise assignment operators &=, |=, ^= for Bitmask aren't yet implemented.

# Unary bitwise operations support
Operation | Bit | Bitmask
----------|-----|--------
~ | Yes | Yes

# Binary bitwise operations support
The following table shows the binary bitwise operations on the side and the pairs of instances they operate on along the top. The cells contain the return types of the operation.

 | Bit/Bit | Bit/Bitmask | Bitmask/Bit | Bitmask/Bitmask
 |---------|-------------|-------------|----------------
& | Bit | Bit | Bit | Bitmask
\| | Bitmask | Bitmask | Bitmask | Bitmask
^ | Bitmask | Bitmask | Bitmask | Bitmask
